\documentclass[polish, 11pt]{article}
    
\usepackage[a4paper, margin=25mm]{geometry}
\usepackage{babel,polski}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{booktabs,multirow,multicol}
\usepackage{pdfpages}

\usepackage{float}
\usepackage{graphicx}
\graphicspath{}

\usepackage{xcolor}
\usepackage[font=small,labelfont=bf]{caption}
\captionsetup[figure]{name=Rys.}

\newcommand{\results}[3][1.0]{
	\includegraphics[width=#1\textwidth]{#2}
	\captionof{figure}{#3\label{fig:#2}}
}
\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}
\renewcommand{\thesubsubsection}{\alph{subsubsection})}
\renewcommand{\theparagraph}{\textbullet}       % kropki czy kolejne rzymskie czy coś innego?
%\renewcommand{\theparagraph}{\Roman{paragraph}}

\begin{document}
\begin{titlepage}
    \centering
    {\scshape\Huge\bfseries Bazy Danych\\ projekt \par}
    \vspace{1cm}
   
    {\itshape\Large Janusz Długosz --- 235746\/\par}
    {\itshape\Large Jakub Dorda --- 235013\/\par}
    {\itshape\Large Marcin Kotas --- 235098\/\par}
    \vfill
    Prowadzący:\par
    Dr inż.~Dariusz \textsc{Jankowski}

    \vfill

    {\large Wrocław, \today\par}

\end{titlepage}

\tableofcontents
\newpage

\section{Wstęp teoretyczny}
    \subsection{Podstawy relacyjnych baz danych}
    Relacyjna baza danych jest zbiorem schematów tabel i relacji między nimi. Służą to przechowywania przeważnie dużych 
    zbiorów danych w ściśle określony sposób.
    Relacyjne bazy danych są jednym z trzech istniejących komercyjnie modelów, oprócz niej istnieją również bazy hierarchiczne
    i obiektowe, jednak nie cieszą się one tak dużą popularnością. Model relacyjny został opracowany przez Edgara Frank Codda
    w latach 70 ubiegłego wieku.
    Model organizuje dane w jedną lub więcej tabel składającą się z kolumn i rekordów (wierszy). Każdy rekord musi posiadać
    unikalny klucz, który go identyfikuje. Generalnie jedna tabela reprezentuje jeden typ encji (np. budynek).
    Rekordy przedstawiają instancje encji (np. ratusz), a w kolumnach przechowywane są atrybuty i informacje (np. rozmiar, rok budowy).
    	\subparagraph{Tabela\\}
    	To struktura przechowująca dane ściśle określonego typu. Tabela zawiera rekordy, które posiadają swoje atrybuty.
    	Struktury te można łączyć relacjami.
	  	\subparagraph{Klucze\\}
  		Każdy rekord posiada swój unikalny klucz. Pozwalają one na jednoznaczną identyfikację wiersza.
  	 Dzięki tym kluczom można łączyć rekordy między różnymi tabelami. To umożliwia modelowanie relacji. 
  		\begin{itemize}
  	 	\item \textbf{KLUCZ PODSTAWOWY (PRIMARY KEY)}\\
  	 	 To klucz identyfikujący jednoznacznie wiersz. Tabela może mieć tylko jeden taki klucz (nie może się powtarzać).
  	 	 Klucze te dzielą się na naturalne oraz sztuczne. Naturalne takie jak np. numer PESEL lub e-mail(koniecznie musi być unikalny) 
  	 	 jest z punktu widzenia systemu tak samo jak inne atrybuty jak np. nazwa firmy. Jeśli nie istnieje rzeczywisty identyfikator 
  	 	 to nadawany jest klucz sztuczny, który znajduję się w dodatkowo stworzonej kolumnie z możliwie jak najkrótszym kluczem.
  	 	 Zazwyczaj będą to kolejne liczby naturalne. 
  	 	 \item \textbf{KLUCZ OBCY (FOREIGN KEY)}\\
  	 	 Są to atrybuty, które wskazują na klucz podstawowy w innej tabeli, jest to po prostu relacja między dwoma tabelami.
  	 	 W tabeli, która jest powiązana kluczem obcym należy powielić całą strukturę, aby możliwe było wiązanie rekordów z
  	 	 dwóch różnych tabel. Z definicji pilnowane jest, aby w wartościach klucza obcego, mogły się znaleźć tylko wartości
  	 	 rzeczywiście istniejące jako klucz główny w innej tabeli. Klucz obcy może oczywiście dotyczyć również tej samej tabeli.
  	 	\end{itemize}
  	 	
  	 	\subparagraph{Relacje\\}
  	 	Relacje opisują związki między tabelami. Dobrze zaprojektowane relacje znacznie upraszczają prawidłowe działanie bazy danych,
  	 	poziom skomplikowania i czytelność kwerend. Poprzez nie  projektowana jest odpowiednia logika struktury bazy.
  	 	\begin{itemize}
  	 	\item \textbf{RELACJA 1:1}\\
  	 	Każdy rekord w pierwszej tabeli może mieć tylko jednego odpowiednika w drugiej tabeli i vice versa. 
  	 	Taką sytuację można rozpatrywać jako jedną dużą tabelę podzieloną na dwie mniejsze. Stosowany gdy 
  	 	część atrybutów tabeli można oddzielić, ponieważ może zostać użyta jako część innej tabli lub dotyczy 
  	 	tylko części atrybutów całej tabeli. Działanie takie poprawia czytelność oraz funkcjonalność bazy danych. Można 
  	 	też wydzielić część atrybutów, które są rzadko odpytywane.
  	 	\item \textbf{RELACJA 1:N}\\
  	 	Jest to relacja występująca najczęściej w relacyjnym modelu bazy danych. Występuje kiedy jeden element pierwszego 
  	 	zbioru może zostać powiązany z wieloma elementami zbioru drugiego. 
  	 	\item \textbf{RELACJA N:N}\\
  	 	Realizowany jest jako dwie relacje 1:N. Jeśli między tabelą pierwszą, a drugą ma zostać zaprojektowana taka relacja to potrzebna jest jeszcze 
  	 	trzecia tabela, która będzie pełniła funkcję łącznika. 
  	 	\end{itemize}
  	 	\subparagraph{Operacje na tabelach\\}
  	 	Są to operacje, które można wykonać w relacyjnych bazach danych. Pierwsze cztery bazują na matematycznej teorii mnogości.
  	 	\begin{itemize}
  	 	\item \texttt{UNION} - suma zbiorów, zwraca wszystkie rekordy pierwszej i drugiej tabeli bez duplikatów.
  	 	\item \texttt{INTERSECTION} - iloczyn zbiorów, zwraca tylko rekordy będące częścią wspólną pierwszej i drugiej tabeli.
  	 	\item \texttt{EXCEPT} - różnica zbiorów, zwraca rekordy z pierwszej tabeli bez części wspólnej pierwszej i drugiej tabeli.
  	 	\item \texttt{CROSS JOIN} - iloczyn kartezjański, zwraca iloczyn kartezjański dwóch tabel, czyli wszystkie możliwe kombinacje połączenia
  	 	rekordów tych tabel.
  	 	\item \texttt{SELECT} + \texttt{WHERE} - zwraca wybrane rekordy z tabeli, które spełniają określony warunek.
  	 	\item \textbf{PROJECTION OPERATION} - zwraca tylko wybrane atrybuty z rekordów.
  	 	\item \texttt{JOIN} - zwraca połączone tabele, które łączy relacja.
  	 	\item \textbf{DIVISION} - jest operacją przeciwną do ilorazu kartezjańskiego.
  	 	\end{itemize}
  		
  		
    

    \subsection{Normalizacja}

\section{Część praktyczna projektu}
    \subsection{Przedstawienie problemu}
    Zadanie projektowe ma na celu stworzenia bazy danych do szybkiej, bezpieczniej, bezproblemowej rezerwacji apartamentów oraz możliwości stworzenia
    aplikacji obsługującą tą bazę danych. 
    W dzisiejszych czasach ludzie bardzo często dużo pracują i są przemęczeni, notorycznie brakuje im czasu. Mając urlop chcieliby szybko
    i łatwo znaleźć sobie miejsce na chwilę relaksu. Wielu ludzi nie potrafi samemu sobie wyszukać i zorganizować takiego wypoczynku, a poza tym
    szukanie apartamentów w różnych miejscach, stronach internetowych jest czasochłonne i nieefektywne.
	\begin{itemize}
     \item Użytkownik powinien być w stanie szybko wyszukać zakwaterowanie na całym świecie i przede wszystkim porównać je za pomocą interesujących go 			 parametrów takich jak cena, lokalizacja, rozmiar.
     \item Dużym atutem byłaby możliwość sortowania rosnąco lub malejąco według parametrów oraz mechanizm filtracji.
     \item Kolejnym problemem jaki może napotkać użytkownik jest przebieg płatności. Klientowi zależy, aby płatność była bezpieczna, szybka i uniwersalna,
     czyli taka sama dla rezerwacji każdego apartamentu.
     \item Użytkownik powinien mieć możliwość stworzenia konta i śledzenia historii swoich rezerwacji oraz
     anulowania jej.
    \end{itemize}    
    Odbiorcą takiego systemu będzie zwykły człowiek, więc powinien on być jak najprostszy i najbardziej intuicyjny w obsłudze, 
    żeby nawet osoba starsza lub w ogóle nie zaznajomiona z technologią mogła z niej z łatwością korzystać. Baza danych powinna nawiązać 
    współpracę z jak największą ilością agencji zajmujących się wynajmem apartamentów, aby zapewnić jak największy wybór zakwaterowania.  
    Aplikacja powinna być wykonana w technologii webowej. Umożliwiłoby to użytkownikowi dostęp do niej w każdym miejscu bez
    instalowania dodatkowego oprogramowania, co mogłoby przerastać część grupy docelowej.
       
     

    \subsection{Wymagania systemu}
    
    \subsection{Model danych ERD}
        \subsubsection{Identyfikacja zbioru encji wraz z ich atrybutami kluczowymi}
            W systemie wyodrębnione zostały następujące encje oraz identyfikujące je atrybuty:
            \begin{table}[h]
                \centering
                \caption{Encje i identyfikatory}\label{tab:entitiesID}
                \begin{tabular}{cc}\toprule
                    Encja   	    &	Atrybut	\\\midrule
                    Locations	    &	Location\_ID	\\
                    Agencies	    &	Agency\_ID	\\
                    Users   	    &	User\_ID	\\
                    Apartments	    &	Apartment\_ID	\\
                    Reservations	&	Reservation\_ID	\\
                    Payments	    &	Payment\_ID	\\
                \bottomrule
                \end{tabular}
            \end{table}

        \subsubsection{Identyfikacja bezpośrednich zależności między encjami}
            Badane jest bezpośrednie powiązanie pomiędzy wszystkimi parami obiektów w systemie.
            Biorąc pod uwagę każdą parę obiektów A i B sprawdzamy czy każde wystąpienie obiektu typu A
            może być powiązane z pewnym wystąpieniem obiektu typu B bez udziału innego pośredniego obiektu.
            Uwzględniamy jednak tylko powiązania istotne z punktu widzenia systemu,
            to znaczy takie powiązania, o których informacja powinna być utrzymana w systemie,
            ponieważ odzwierciedlają one reguły i zasady panujące w organizacji użytkownika.
            Wykryte powiązania przedstawiliśmy w tak zwanej tablicy krzyżowej (tablica~\ref{tab:cross}),
            w których znakiem X oznaczono istnienie bezpośredniego, istotnego powiązania.
            \begin{table}[h]
                \centering
                \caption{Tabela krzyżowa, zależności bezpośrednie pomiędzy encjami}\label{tab:cross}
                \begin{tabular}{ccccccc}\toprule
                    &	Locations	&	Agencies	&	Users	&	Apartments	&	Reservations	&	Payments	\\\midrule
                    Locations	    &		&	X	&	X	&	X	&		&		\\
                    Agencies	    &	X	&		&		&	X	&		&		\\
                    Users	        &	X	&		&		&	X	&	X	&		\\
                    Apartments	    &	X	&	X	&	X	&		&	X	&		\\
                    Reservations	&		&		&	X	&	X	&		&	X	\\
                    Payments	    &		&		&		&		&	X	&		\\
                \bottomrule
                \end{tabular}
            \end{table}

            \begin{table}[H]
                \centering
                \caption{Opis atrybutów}\label{tab:attributes}
                \begin{tabular}{ll}\toprule
                    \multicolumn{1}{c}{Atrybut}	&	\multicolumn{1}{c}{Opis}\\\midrule
                    Location\_ID	&	Identyfikator lokalizacji	\\
                    Country\_Name	&	Nazwa państwa	\\
                    City	&	Nazwa miasta	\\
                    Longitude	&	Długość geograficzna	\\
                    Latitude	&	Szerokość geograficzna	\\
                    Street	&	Adres	\\
                    Street2	&	Adres c.d.	\\
                    Apartment\_Number	&	Nr mieszkania	\\
                    Zip\_Code	&	Kod pocztowy	\\
                    Agency\_ID	&	Identyfikator agencji	\\
                    Agencies.Name	&	Nazwa agencji	\\
                    Agencies.Info	&	Informacje o agencji	\\
                    Phone	&	Nr telefonu	\\
                    Web	&	Strona internetowa	\\
                    User\_ID	&	Identyfikator użytkownika	\\
                    Users.Type	&	Typ użytkownika (właściciel | klient)	\\
                    Email	&	Adres email	\\
                    Password	&	Hasło użytkownika	\\
                    Users.Info	&	Informacje o użytkowniku	\\
                    Users.Name	&	Imię użytkownika	\\
                    Last\_Name	&	Nazwisko użytkownika	\\
                    Apartment\_ID	&	Identyfikator apartamentu	\\
                    Cost\_Per\_Night	&	Koszt za jedną noc	\\
                    Bed\_Count	&	Liczba łóżek w apartamencie	\\
                    Air\_Cond	&	Klimatyzacja w apartamencie na wyposażeniu	\\
                    Standard	&	Standard apartamentu (1 --- 5)	\\
                    Owner\_ID	&	Identyfikator właściciela apartamentu	\\
                    Reservation\_ID	&	Identyfikator rezerwacji	\\
                    Date\_Begin	&	Data rozpoczęcia pobytu	\\
                    Date\_End	&	Data zakończenia pobytu	\\
                    Reservations.Status	&	Status rezerwacji (rozpoczęta | zaakceptowana | zakończona)	\\
                    Payment\_ID	&	Identyfikator wpłaty	\\
                    Payments.Type	&	Typ wpłaty (zaliczka | całość)	\\
                    Value	&	Wartość wpłaty	\\
                    Payments.Status	&	Status wpłaty (rozpoczęta | zakończona | anulowana | zwrócona)	\\
                \bottomrule
                \end{tabular}
            \end{table}

            \begin{table}[H]
                \centering
                \caption{Wykaz encji i powiązanych z nimi atrybutów}\label{tab:entitiesAttributes}
                \begin{tabular}{lp{0.8\linewidth}}\toprule
                    \multicolumn{1}{c}{Encja}	&	\multicolumn{1}{c}{Atrybut}	\\\midrule
                    Locations	&	Location\_ID, Country\_Name, City, Longitude, Latitude, Street, Street2, Apartment\_Number, Zip\_Code	\\
                    Agencies	&	Agency\_ID, Location\_ID, Name, Info, Phone, Web	\\
                    Users	&	User\_ID, Type, Email, Password, Info, Phone, Name, Last\_Name, Location\_ID	\\
                    Apartments	&	Apartment\_ID, Cost\_Per\_Night, Bed\_Count, Location\_ID, Agency\_ID, Air\_Cond, Standard, Owner\_ID	\\
                    Reservations	&	Reservation\_ID, Date\_Begin, Date\_End, Apartment\_ID, User\_ID, Status	\\
                    Payments	&	Payment\_ID, Reservation\_ID, Type, Value, Status	\\
                \bottomrule
                \end{tabular}
            \end{table}

            \begin{table}[H]
                \centering
                \caption{Opis związków pomiędzy encjami}\label{tab:relations}
                \begin{tabular}{ll}\toprule
                    \multicolumn{1}{c}{Związek}	&	\multicolumn{1}{c}{Opis}	\\\midrule
                    Posiada	&	Agencies --- Locations; 1:1	\\
                    Posiada	&	Users --- Locations; 1:1	\\
                    Posiada	&	Apartments --- Locations; 1:1	\\
                    Ma	&	Apartments --- Agencies; N:1	\\
                    Ma	&	Apartments --- Users; N:1	\\
                    Dotyczy	&	Reservations --- Apartments; N:1	\\
                    Dotyczy	&	Reservations --- Users; N:1	\\
                    Dotyczy	&	Payments --- Reservations; 1:1	\\
                \bottomrule
                \end{tabular}
            \end{table}

    \subsection{Schemat diagramu ERD}
	    \subsubsection{Opis aplikacji w której modelowano schemat}
		    W celu wygenerowania diagramu ERD użyto aplikacji {\bfseries DataGrip} oferowanej przez firmę JetBrains. 
		    Jest to IDE obsługujące większość popularnych odmian SQL oraz związanych z nimi systemów bazodanowych.\\\\
		    Aby wygenerować diagram ERD należy nawiązać połączenie z wybranym serverem hostującym system
		    bazodanowy. Po zalogowaniu kliknąć prawym przyciskiem myszy na obecne połączenie i z menu kontekstowego
		    wybrać opcję {\bfseries'Diagrams' -> 'Show visualization'}, po kliknięciu w nowej zakładce wygeneruje się wizualizacja
		    ERD. Diagram jest automatycznie generowany z encji dostępnych dla zalogowanego użytkownika. Widok pozwala jedynie na
		    odczyt struktury bazy danych w formie graficznym, bez możliwości edycji. Użytkownik ma możliwość eksportu widoku
		    do pliku w formacie graficznym, diagramu UML oraz PostScript lub wydrukowania diagramu na drukarce. Zmiany uwzględniane
		    są na bieżąco po każdej operacji ingerującej w strukturę bazy danych.\\\\
		    Wizualizacja została zaimplementowana z wykorzystaniem biblioteki {\bfseries yFiles}
	    
	    \subsubsection{Prezentacja schematu ERD bazy danych}
		    \includepdf{../data/out.pdf}

    \subsection{Rozwiązanie problemu}
	    \subsubsection{System bazodanowy}
		    \paragraph{Utworzenie bazy danych}\mbox{}\\\\
			    Zgodnie z założeniami projektu wykorzystano system bazodanowy oferowany przez firmę Oracle - 
			    {\bfseries Oracle Database 11g Express Edition Release 2} w wersji na system Linux z architekturą 64 bitową.
			    Firma Oracle wspiera jedynie dystrybucje Linuxa wykorzystujące {\bfseries RPM Package Manager} jako system dystrybucji paczek.
			    Oracle Database jest produktem komercyjnym z zamkniętym źródłem, więc nie istnieje możliwość samodzielnej kompilacji
			    na dowolnej dystrybucji Linuxa.\\\\
			    W celu usprawnienia pracy nad projektem oraz umożliwieniem dostępu do bazy danych dla każdego członka grupy projektowej,
			    za pośrednictwem strony {\bfseries digitalocean.com} utworzono maszynę wirtualną Linuxa z dystrybucją {\bfseries CentOS 7.5},
			    który wspiera paczki RPM. Po utworzeniu maszyny i podaniu publicznego klucza RSA można zalogować się na nowo utworzony serwer
			    przy pomocy SSH. Każda maszyna wirtualna otrzymuje bezpośredni, zewnętrzny adres IP.\\\\
			    W celu instalacji produktu Oracle należy najpierw zarejestrować się na stronie korporacji. Po zalogowaniu otrzymujemy link
			    z indywidualnym tokenem autoryzacyjnym, po skopiowaniu linku możemy pobrać spakowany paczkę przy pomocy programu 
			    {\bfseries curl} lub {\bfseries wget} bezpośrednio na nasz serwer. Następnie trzeba ją rozpakować używając komendy {\bfseries unzip}.
			    Przed instalacją należy upewnić się, że nasz system spełnia wymagania określone przez Oracle. Należy doinstalować wymagane
			    paczki na których bazuje system bazodanowy Oracle - {\bfseries libaio, bc, oraz flex}. Można to wykonać automatycznie
			    korzystając z managera paczek {\bfseries YUM}, który jest domyślnym systemem zarządzania paczkami w systemie CentOS.
			    Składnia jest następująca: {\bfseries yum install libaio bc flex}. Oprócz tego, Oracle wymaga by w systemie znajdowała się
			    aktywna partycja swap lub swapfile o minimalnym rozmiarze 2GB. Po wypakowaniu pliku instalujemy paczkę przy pomocy
			    {\bfseries rpm -i <nazwa paczki>}. Po zakończeniu instalacji, przed pierwszym użyciem należy skonfigurować serwis hostujący
			    bazę Oracle. W tym celu musimy wywołać konfigurator jako root poleceniem: {\bfseries /etc/init.d/oracle-xe configure}. Konfiguracja
			    prosi o nadanie hasła dla użytkowników {\bfseries SYS/SYSTEM}, będących administratorami bazy Oracle, określenie portów dla serwera
			    HTTP oraz listenera bazy danych, oraz czy chcemy by serwis załączał się automatycznie przy starcie hosta.\\\\
			    Po wykonaniu tych operacji możemy zalogować się po IP serwera na użytkownika {\bfseries SYSTEM} w celu dalszej konfiguracji bazy danych,
			    którą można wykonać przy pomocy zapytań SQL. W pierwszej kolejności utworzono użytkownika do którego będą należeć encje projektu.
			    Oprócz tego stworzono użytkownika i nadano odpowiednie uprawnienia dla każdego członka zespołu projektowego. Dzięki zastosowaniu
			    synonimów/aliasów publicznych - {\bfseries CREATE PUBLIC SYNONYM ...} encje oraz funkcje projektu są dostępne dla każdego członka
			    zespołu bez konieczności adresowania z uwzględnieniem właściciela.\\\\ 
			    Takie rozwiązanie umożliwia równoległą pracę nad jedną bazą danych dla wielu użytkowników fizycznych, w dowolnym miejscu i czasie.
		    
		    \paragraph{Implementacja obiektów}\mbox{}\\\\
		    
		    \paragraph{Wprowadzenie danych}\mbox{}\\\\
		    
		    \paragraph{Zdefiniowanie typowych operacji SQL}\mbox{}\\\\

    \subsection{Podsumowanie}
	    \subsubsection{Ocena realizacji tematu}
	    
		\subsubsection{Wnioski}

\section{Literatura}

\end{document}